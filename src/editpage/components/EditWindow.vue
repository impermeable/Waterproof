<template>
  <div class="edit-window" ref="domEl" :id="'edit-window-' + tabindex"
      @contextmenu="openContextMenu($event)"
      @click="insertTextBlock()">
    <Gutter :ani="ani" ref="execGutter" :height="gutterHeight"
            :exec-height="execHeight" :exec-height-ball="execHeightBall"
            :pending-height="pendingHeight"
            :pending-height-ball="pendingHeightBall"
            :executed="executed"/>
    <div ref="editPane"
        class="edit-pane"
        @click.self="onClick"
        @paste="paste">
      <inter-block
          :key="'interblock-' + 0"
          :block="null" :exercise="exercise"
          :active="selectedInterblock === 0"
          :wide="true"
          :index="0">
      </inter-block>
      <template v-for="(block, index) in blocks">
        <component v-show="!block.state.foldStatus.isFolded"
                  :is="toComponent(block.type)" :block="block"
                  :key="block.type + index" :index="index"
                  :sentences="sentenceIndices"
                  :executedIndex="executeIndex" :runningIndex="runningIndex"
                  :exercise="exercise" :event-bus="eventBus">
        </component>
        <fold-block v-if="block.state.foldStatus.startFold"
                    :key="block.type + index + '+'"
                    :event-bus="eventBus"
                    :block="block" :index="index"
                    :exercise="exercise"></fold-block>
        <div v-if="index === focusedElement"
            :key="'holder-' + index " class="edit-holder"
            :class="{floatyEditor: floating}">
          <codemirror id="source-editor" :key="'editor' + index"
                  class="edit-text" :value="block.text"
                  :options="getCMOptions(block.type)"
                  @ready="onCmReady" @changes="onChanges"
                  @keyHandled="keyup" @cursorActivity="cursorMove"
                  ref="codeMirrors">
          </codemirror>
          <!-- Placeholder for toggling the assistance bar -->
          <div v-if="block.type === 'code'"
            @click="toggleAssistanceBar"
            class="toggle-bar">
          </div>
          <assistance-bar v-show="isShowingAssistance"
            v-if="block.type === 'code'"
            :event-bus="eventBus">
          </assistance-bar>
        </div>

        <inter-block :key="'interblock-' + index + 1"
            :block="block" :exercise="exercise"
            :active="selectedInterblock === index + 1"
            :wide="block.start"
            :index="index + 1">
        </inter-block>

      </template>
      <find ref="find" v-show="showFind"
            :event-bus="eventBus"
            v-bind:blocks="blocks" v-bind:exercise="exercise" />
    </div>
    <block-context-menu ref="menu"
        :event-bus="eventBus" :blocks="blocks" :shortKeys="shortKeys">
    </block-context-menu>
  </div>
</template>

<script>
import {codemirror} from 'vue-codemirror';
import 'codemirror/lib/codemirror.css';
import 'codemirror/addon/display/placeholder';
import 'codemirror/addon/search/searchcursor';
import 'codemirror/addon/edit/matchbrackets';
import debounce from 'lodash.debounce';

import CodeBlock from './blocks/code/CodeBlock';
import TextBlock from './blocks/TextBlock';
import HintBlock from './blocks/HintBlock';
import InputBlock from './blocks/InputBlock';
import FoldBlock from './blocks/FoldBlock';
import InterBlock from './blocks/InterBlock';
import CoqInterface from '../../coq/CoqInterface';
import BlockContextMenu from './blocks/BlockContextMenu';
import AssistanceBar from './assistance/AssistanceBar';
import Find from './Find';
import Gutter from './Gutter';
import CodeExecution from './mixins/CodeExecution';
import CodeMirrorHandler from './mixins/CodeMirrorHandler';
import {writeActivity} from '@/activity-log';

export default {
  name: 'EditWindow',
  mixins: [CodeExecution, CodeMirrorHandler],
  components: {
    codemirror,
    Gutter, Find,
    TextBlock, CodeBlock, HintBlock, InputBlock, FoldBlock, InterBlock,
    BlockContextMenu, AssistanceBar,
  },
  props: {
    executeIndex: Number,
    coq: CoqInterface,
    pendingIndex: Number,
    blocks: Array,
    exercise: Boolean,
    debug: Boolean,
    showFind: Boolean,
    shortKeys: Object,
    tabindex: Number,
    eventBus: Object,
    notebookUri: String,
  },
  data: function() {
    return {
      floating: false,
      executed: false,
      nextCursorPos: -1,
      execHeight: 0,
      execHeightBall: 0,
      gutterHeight: 100,
      timer: null,
      cursorPos: null,
      isShowingAssistance: true,
      ani: true,
      focusedElement: -1,
      dispatchTextChange: debounce((type, blockIndex, newValue) => {
        // Don't update the block text yet. This is done in proofwindow so it
        // can detect the changes to allow undoing them
        this.eventBus.$emit('changeInput', type, blockIndex, newValue);
      }, 250, {leading: true, maxWait: 2500, trailing: true}),
      selectedInterblock: -1,
    };
  },
  mounted: function() {
    // setTimeout is called after dom completes
    setTimeout(() => this.setGutterHeight(), 0);
    this.eventBus.$on('set-focus', this.setFocusedElement);
  },
  methods: {
    onChanges: function(cm) {
      const value = cm.getValue();

      this.dispatchTextChange('input', this.focusedElement, value);
      this.refreshExecStatus(false);
    },
    toComponent: function(type) {
      if (type === 'code') {
        return 'code-block';
      } else if (type === 'hint') {
        return 'hint-block';
      } else if (type === 'input') {
        return 'input-block';
      } else {
        return 'text-block';
      }
    },
    exerciseIndexForBlockIndex(index) {
      let beforeOrInExercise = 0;
      let inInputBlock = false;

      if (index >= this.blocks.length) {
        return {beforeOrInExercise, inInputBlock, error: 'out-of-range'};
      }


      for (let i = 0; i < index; i++) {
        const block = this.blocks[i];
        if (block.type !== 'input') {
          continue;
        }

        if (block.start) {
          inInputBlock = true;
        } else {
          inInputBlock = false;
          ++beforeOrInExercise;
        }
      }

      return {beforeOrInExercise, inInputBlock};
    },
    setFocusedElement: function(index, {find = false, cursorIndex = -1} = {}) {
      writeActivity('focusing-block', {
        tabIndex: this.tabIndex,
        file: this.notebookUri,
        blockIndex: index,
        cursorIndex: cursorIndex,
        exerciseIndex: this.exerciseIndexForBlockIndex(index),
      });
      if (this.focusedElement === index) {
        // If we click again on the element that already has focus, it should
        // already have a CodeMirror open. So, we make sure to just focus on it
        if (this.$refs.codeMirrors && this.$refs.codeMirrors.length === 1) {
          const cm = this.$refs.codeMirrors[0].codemirror;
          if (!find) {
            cm.setCursor(cm.posFromIndex(cursorIndex));
            this.cursorMove(cm);
          }
          cm.focus();
          return;
        }
      }
      if (!find) {
        this.nextCursorPos = cursorIndex;
      }
      this.selectedInterblock = -1;
      if (this.focusedElement !== -1) {
        const isAfterSource = index > this.focusedElement;
        if (this.blurSource() && isAfterSource) {
          index--;
        }
      }

      this.$refs.find.changeFocusedElement(index, find);
      this.focusedElement = index;
      this.refreshExecStatus(false);
    },
    setFocusedInterblock: function(index) {
      const isAfterSource = index > this.focusedElement;
      if (this.blurSource() && isAfterSource) {
        index--;
      }
      this.selectedInterblock = index;
    },
    blurSource: function() {
      this.selectedInterblock = -1;

      if (this.focusedElement === -1 ||
          this.focusedElement >= this.blocks.length) {
        this.focusedElement = -1;
        this.cursorPos = {block: this.focusedElement};
        this.eventBus.$emit('setCursorPos', this.cursorPos);
        return false;
      }

      this.dispatchTextChange.flush();

      let removed = false;

      if (this.blocks[this.focusedElement].text === '') {
        removed = true;
        writeActivity('emptied-block', {
          tabIndex: this.tabIndex,
          file: this.notebookUri,
          blockIndex: this.focusedElement,
          blockType: this.blocks[this.focusedElement].type,
        });
        this.dispatchTextChange(
            'remove-block',
            this.focusedElement,
            null,
            this
        );
        this.dispatchTextChange.flush();
      }

      this.focusedElement = -1;
      this.cursorPos = {block: this.focusedElement};
      this.eventBus.$emit('setCursorPos', this.cursorPos);

      this.$refs.find.currentCm = null;

      this.refreshExecStatus(false);

      return removed;
    },

    // blurCM: function() {
    //   document.querySelector('.CodeMirror-cursors')
    //       .style.visibility = 'visible';
    // },
    onCmReady: function(cm) {
      let cursorPos = this.nextCursorPos;
      if (cursorPos < 0) {
        cursorPos = cm.getValue().length;
      }
      cm.setCursor(cm.posFromIndex(cursorPos));
      this.cursorMove(cm);

      cm.focus();
      this.$refs.find.currentCm = cm;
      this.$refs.find.onCodeMirrorReady();
      this.$refs.find.onCodeMirrorReady = () => {};

      cm.on('paste', this.cmPaste);
    },
    moveSelection: function(event) {
      if (event.srcKey === 'Right' || event.srcKey === 'Down') {
        for (let i = this.selectedInterblock; i < this.blocks.length; i++) {
          if (this.isEditableBlock(this.blocks[i])) {
            this.setFocusedElement(i);
            this.$nextTick(() => {
              this.$refs.codeMirrors[0].codemirror.execCommand('goDocStart');
            });
            break;
          }
        }
      } else if (this.selectedInterblock > 0 &&
          !this.blocks[this.selectedInterblock - 1].start) {
        this.setFocusedElement(this.selectedInterblock - 1);
      }
    },
    keyup: function(cm, key, event) {
      if (event.shiftKey ||
          !(key.includes('Right')
            || key.includes('Left')
            || key.includes('Up')
            || key.includes('Down'))) {
        return;
      }

      const cursorIndex = cm.indexFromPos(this.cursorPos.from);
      const cursorLine = this.cursorPos.line;

      if (key.includes('Right') && cursorIndex === cm.getValue().length
          || key.includes('Down') && cursorLine === cm.lineCount() - 1) {
        this.setFocusedInterblock(this.focusedElement + 1);
      } else if (key.includes('Left') && cursorIndex === 0
          || key.includes('Up') && cursorLine === 0) {
        for (let i = this.focusedElement - 1; i >= 0; i--) {
          if (this.blocks[i].type === 'input' && this.blocks[i].start
              || this.isEditableBlock(this.blocks[i])) {
            this.setFocusedInterblock(i + 1);
            return;
          }
        }
        if (!this.exercise) {
          this.setFocusedInterblock(0);
        }
      }
    },
    isEditableBlock: function(block) {
      const skippedTypes = ['input'];
      return !skippedTypes.includes(block.type)
          && (!this.exercise || block.state.inInputField);
    },
    toggleAssistanceBar() {
      this.isShowingAssistance = !this.isShowingAssistance;
    },
    findCodeIndex(index, clamp) {
      if (index < 0) {
        return null;
      }
      let len = 0;
      let lastCodeBlock = -1;
      for (let i = 0; i < this.blocks.length; i++) {
        const block = this.blocks[i];
        if (block.type !== 'code') {
          continue;
        }
        lastCodeBlock = i;
        const newLen = len + block.text.length + 1;
        if (newLen > index) {
          return {blockIndex: i, posInBlock: index - len};
        }
        len = newLen;
      }
      if (clamp) {
        const block = this.blocks[lastCodeBlock];
        const posInBlock = block.text.length;
        return {blockIndex: lastCodeBlock, posInBlock};
      } else {
        return null;
      }
    },
    /**
     * Changes height of gutter to the height of the editpane,
     * adds 100 px as well for 'overleaf-scrolling'
     */
    setGutterHeight: function() {
      const editPane = this.$refs.editPane;
      this.gutterHeight = editPane.scrollHeight + 100;
    },
    alignGutter: function(animation = true) {
      this.ani = animation;
      requestAnimationFrame(() => {
      // Set the gutter height to equal content height
        this.setGutterHeight();

        const execTick = this.$refs.editPane
            .querySelector('.sentence-end-' + this.executeIndex);

        const editPane = this.$refs.editPane;
        const rect2 = editPane.getBoundingClientRect();

        if (execTick != null) {
          const rect = execTick.getBoundingClientRect();

          this.execHeight = (rect.bottom + rect.top) / 2 - rect2.top - 10;
          this.execHeightBall = rect.top - rect2.top;
        } else if (this.executeIndex >= 0) {
          console.log('Cannot find sentence end: ', this.executeIndex);
        }

        const pendingTick = this.$refs.editPane
            .querySelector('.sentence-end-' + this.pendingIndex);

        if (pendingTick != null) {
          const rect = pendingTick.getBoundingClientRect();

          this.pendingHeight = (rect.bottom + rect.top) / 2 - rect2.top - 10;
          this.pendingHeightBall = rect.top - rect2.top;
        } else if (this.pendingIndex >= 0) {
          console.log('Cannot find sentence end: ', this.pendingIndex);
        }

        if (!animation) {
          setTimeout(() => {
            this.ani = true;
          }, 0);
        }
      });
    },
    insertTextBlock: function() {
      if (this.blocks.length === 0) {
        this.eventBus.$emit('insertText');
      }
    },
    openContextMenu: function(event) {
      this.$refs.menu.open(event);
    },
    paste: function(event) {
      this.$refs.menu.paste(event);
    },
    cmPaste: function(cm, event) {
      this.paste(event);
    },
    onClick: function() {
      this.$refs.find.resetFind();
      this.blurSource();
    },
  },
  computed: {
    sentenceIndices() {
      const sentences = [];
      for (let i = 0; i < this.coq.getState().sentenceSize(); i++) {
        sentences.push(this.coq.getState().endIndexOfSentence(i));
      }
      return sentences;
    },
    runningIndex() {
      if (this.pendingIndex <= this.executeIndex) {
        return this.executeIndex;
      }
      const index = this.sentenceIndices.indexOf(this.executeIndex) + 1;
      return this.sentenceIndices[index];
    },
  },
  watch: {
    executeIndex: function() {
      this.refreshExecStatus(true);
    },
    pendingIndex: function() {
      this.refreshExecStatus(true);
    },
  },
  /**
   * Checks if DOM elements are changed and if so,
   * sets the gutter height accordingly.
   */
  beforeUpdate: function() {
    this.setGutterHeight();
  },
};
</script>

<style lang="scss">
@import "../../assets/sass/pages/edit.scss";

#source-editor {
  width: 100%;
  @include theme(border, color-black, 1px solid);
}


.CodeMirror-placeholder {
  @include theme(background-color, color-gray, null, !important);
}

.edit-window {
  //Sean: dit zou mss leuk zijn: @include theme(border, color-gray, 1px solid);
  display: flex;
  flex: 1 0 50%;
  min-height: 60%;
  position: relative;
  padding: 8px;
  overflow-y: scroll;
}

.highlightText {
  @include theme(background-color, color-primary-extra-light);
}

.edit-holder {
  position: relative;
  margin: 4px 0;
  width: calc(100% - 16px);
}

.edit-pane {
  width: calc(100% - 40px);
}

.no-transition {
  transition: none !important;
}

.toggle-bar {
  @include theme(background-color, color-primary-dark);
  height: 5px;
}

</style>
